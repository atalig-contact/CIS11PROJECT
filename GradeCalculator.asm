.ORIG X3000
AND R0, R0, #0 ;CLEAR
AND R1, R1, #0 ;CLEAR
AND R2, R2, #0 ;CLEAR
AND R3, R3, #0 ;CLEAR
AND R4, R4, #0 ;CLEAR
JSR STACK
JSR DIGITSTACK
JSR MAIN
HALT

;INTRO

;INITIALIZE THE DIGIT STACK**************************************************************************************
DIGITSTACK
  AND R0, R0, #0
  ST R0, DIGITSIZE
  LD R0, DIGITBOTTOM
  ST R0, DIGITTOP
  LD R0, DIGITCAPACITY
  RET

DIGITBOTTOM .FILL x4000   ;base of the stack
DIGITSIZE .BLKW #1      ;
DIGITTOP .BLKW #1       ;will keep pointing to the top of the stack;originally pointing to x4000
DIGITCAPACITY .FILL #3  ;only three elements are allowed in the stack;must 

;DIGIT SUBROUTINE **************************************************************************************************
DIGITPUSH
      ST R1, DIGITSAVER1
      ST R2, DIGITSAVER2
      LD R1, DIGITSIZE
      LD R2, DIGITCAPACITY
      NOT R2, R2        ;compare the size with the capacity by subtracting them
      ADD R2, R2, #1
      ADD R2, R1, R2
      LD R2, DIGITTOP   ;LOAD STACKTOP POINTER TO R2
      ADD R2, R2, #-1   ;MUST ADD -1 AS PUSHING 
      STR R0, R2, #0    ;PUSH element;will change
      ST R2, DIGITTOP   ;UPDATE TOP OF THE STACK
      ADD R1, R1, #1    
      ST R1, DIGITSIZE  ;ADD ONE TO STACKSIZE TO INCREMENT THE size
      ADD R5, R5, #1
      LD R1, DIGITSAVER1
      LD R2, DIGITSAVER2
      RET
DIGITSAVER1  .FILL x0  ;SAVE REGISTER 1
DIGITSAVER2  .FILL x0  ;SAVE REGISTER 2



;DIGIT POP ROUTINE *****************************************************************************************************************
DIGITPOP
      ST R1, DIGITPOPSAVER1
      ST R2, DIGITPOPSAVER2
      AND R5, R5, #0
      LD R1, DIGITSIZE  ;LOAD STACKSIZE TO R1
      BRz ISDIGITEMPTY       ;IF STACKSIZE = 0, CAN NO LONGER POP, CONT TO ISEMPTY SUBROUTINE
      LD R2, DIGITTOP
      LDR R0, R2, #0    ;POP ELEMENT ;USING LDR SINCE WE USED STR IN PUSH SUBROUTINE
      ADD R2, R2, #1    ;MUST ADD 1 AS POPPING
      ST R2, DIGITTOP
      ADD R1, R1, #-1   ;DELETE ONE FROM THE STACKSIZE
      ST R1, DIGITSIZE  ;UPDATE size
      ADD R5, R5, #1
ISDIGITEMPTY ;SUBROUTINE FOR IF STACK IS EMPTY;NO MORE ELEMENTS CAN BE POPPED
      LD R1, DIGITPOPSAVER1
      LD R2, DIGITPOPSAVER2
      RET
DIGITPOPSAVER1 .FILL x0      ;SAVE REGISTER 1
DIGITPOPSAVER2 .FILL x0      ;SAVE REGISTER 2


MAINYPTR .FILL Y
MAINXPTR .FILL X
MAINXTIMESYPTR .FILL XTIMESY
MAINMINPTR .FILL MIN
MAINMAXPTR .FILL MAX
MAINAVGINTPTR .FILL AVGINT
MAINAVGDECPTR .FILL AVGDEC
MAINNPTR .FILL N
MAINDPTR .FILL D
MAINQUOTIENTPTR .FILL QUOTIENT
MAINREMAINDERPTR .FILL REMAINDER

DISPL .STRINGZ "INPUT THREE POSITIVE INTEGERS OF AN ASSIGNMENT GRADE\n" ; Prints display
DISPL3 .STRINGZ "EX: ENTER 97 AS '097'\n"
DISPL2 .STRINGZ "WELCOME TO MIN/MAX/AVG CALCULATOR!\n"; PRINT DISPLAY 2

;MAIN *******************************************************************************************************************
MAIN ST R7, CONVERTADDRESS
OUTERLOOP 
  AND R6,R6,#0
  ADD R6,R6,#3
	LEA R0, DISPL	;LOAD
	PUTS		;PRINT FRIST DISPLAY
	AND R0,R0,#0 	;CLEAR R0
  LEA R0, DISPL3 ;LOAD
  PUTS   ;PRINTS EX DISPLAY
  AND R0,R0,#0
	LEA R0, DISPL2	;LOAD	
	PUTS		;SECOND DISPLAY SCREEN
	AND R0,R0,#0	;CLEAR R0
    DOITAGAIN 	            IN  ;LOOP FOR INPUT : up to 3 times for each digit
    ADD R3, R1, R0            ;GET USER INPUT
    JSR DIGITPUSH		          ;PUSH ON TO STACK
    ADD R6, R6, #-1
    BRp DOITAGAIN             
  JSR DIGITPOP
  JSR DECIMAL		;JUMP TO ASCII TO DECIMAL
  ADD R4, R4, R0
  JSR DIGITPOP
  JSR DECIMAL		;JUMP TO ASCII TO DECIMAL
  STI R0, MAINYPTR
  AND R5, R5, x0
  ADD R5, R5, #10
  STI R5, MAINXPTR
  JSR MULT
  LDI R0, MAINXTIMESYPTR
  ADD R4, R4, R0
  JSR DIGITPOP
  JSR DECIMAL		;JUMP TO ASCII TO DECIMAL
  STI R0,MAINYPTR
  AND R5, R5, x0
  ADD R5, R5, #15
  ADD R5, R5, #15
  ADD R5, R5, #15
  ADD R5, R5, #15
  ADD R5, R5, #15
  ADD R5, R5, #15
  ADD R5, R5, #10
  STI R5, MAINXPTR
  JSR MULT
  LDI R0, MAINXTIMESYPTR
  ADD R4, R4, R0
  ADD R0, R4, #0
  JSR PUSH
  ADD R1, R1, #-1
  BRz OUTERLOOP
  JSR CALMIN		;CALL MINIMUM FUNCTION	
  JSR CALMAX		;CALL MAXIMUM FUNCTION
  JSR CALAVG		;CALL AVERAGE FUNCTION
  LDI R2, MAINMINPTR
  ST R2, VALUE
  JSR CONVERTASCII
  LEA R0, MINDISPL
  PUTS
  JSR DIGITPOP
  OUT
  JSR DIGITPOP
  OUT
  JSR DIGITPOP
  OUT
  AND R0,R0 , #0
  LDI R2, MAINMAXPTR
  ST R2, VALUE
  JSR CONVERTASCII
  LEA R0, MAXDISPL
  PUTS 
  JSR DIGITPOP
  OUT
  JSR DIGITPOP
  OUT
  JSR DIGITPOP
  OUT
  AND R0, R0, #0
  LDI R3, MAINAVGINTPTR
  ST R3, VALUE 
  JSR CONVERTASCII
  LEA R0, AVGDISPL		;DISPLAYS FOR OUTPUTS
  PUTS
  JSR DIGITPOP
  OUT
  JSR DIGITPOP
  OUT
  JSR DIGITPOP
  OUT
  LD R0, DECIMALCHAR ;NOTE:******************************************
  OUT ;OUT decimal character
  LDI R3, MAINAVGDECPTR
  ST R3, VALUE
  JSR CONVERTASCII
  JSR DIGITPOP ; Skip 1st digit
  JSR DIGITPOP
  OUT
  JSR DIGITPOP
  OUT
  AND R0,R0,#0
  JSR LETTERGRADEBRANCH
  LD R7, CONVERTADDRESS
  RET

  CONVERTADDRESS .FILL x0
  MINDISPL .STRINGZ "\nTHIS IS YOUR MINIMUM RESULT : \n"
  MAXDISPL .STRINGZ "\nTHE MAX GRADE IN YOUR CLASS IS : \n"
  AVGDISPL .STRINGZ "\nTHE AVERGAGE GRADE IS : \n"

CONVERTASCII ST R0, CONVERTASCIIRESTORER0    ;CONVERTING BACK TO ASCII *************************************************************************************************************************
  ST R1, CONVERTASCIIRESTORER1
  ST R2, CONVERTASCIIRESTORER2
  ST R7, CONVERTASCIIRESTORER7
  LD R1, VALUE
  STI R1, MIDNPTR
  AND R2, R2, #0
  ADD R2, R2, #10
  STI R2, MIDDPTR
  JSR DIV
  LDI R1 MIDQUOTIENTPTR
  LDI R0 MIDREMAINDERPTR
  JSR ASCII
  JSR DIGITPUSH
  STI R1, MIDNPTR
  STI R2, MIDDPTR
  JSR DIV
  LDI R1 MIDQUOTIENTPTR
  LDI R0 MIDREMAINDERPTR
  JSR ASCII
  JSR DIGITPUSH
  STI R1, MIDNPTR
  STI R2, MIDDPTR
  JSR DIV
  JSR ASCII
  JSR DIGITPUSH
  LD R0, CONVERTASCIIRESTORER0
  LD R1, CONVERTASCIIRESTORER1
  LD R2, CONVERTASCIIRESTORER2
  LD R7, CONVERTASCIIRESTORER7
  RET

  VALUE .FILL x0
  CONVERTASCIIRESTORER0 .FILL x0
  CONVERTASCIIRESTORER1 .FILL x0
  CONVERTASCIIRESTORER2 .FILL x0
  CONVERTASCIIRESTORER7 .FILL x0

MIDYPTR .FILL Y
MIDXPTR .FILL X
MIDXTIMESYPTR .FILL XTIMESY
MIDMINPTR .FILL MIN
MIDMAXPTR .FILL MAX
MIDAVGINTPTR .FILL AVGINT
MIDAVGDECPTR .FILL AVGDEC
MIDNPTR .FILL N
MIDDPTR .FILL D
MIDQUOTIENTPTR .FILL QUOTIENT
MIDREMAINDERPTR .FILL REMAINDER

;LETTER GRADE ***************************************************************************************************************************************************************
  
LETTERGRADEBRANCH ST R0, LETTERGRADEBRANCHRESTORER0
  ST R1, LETTERGRADEBRANCHRESTORER1
  ST R2, LETTERGRADEBRANCHRESTORER2
  ST R7, LETTERGRADEBRANCHRESTORER7
  LDI R2, MIDAVGINTPTR 
  ADD R1, R2, #-15
  ADD R1, R1, #-15
  ADD R1, R1, #-15
  ADD R1 ,R1, #-15
  ADD R1, R1, #-15
  ADD R1 ,R1, #-15
  BRn NEXT
  LEA R0, LETTERGRADEA
  PUTS
  BR SKIP
  NEXT
  ADD R1, R2, #-15
  ADD R1, R1, #-15
  ADD R1, R1, #-15
  ADD R1, R1, #-15
  ADD R1, R1, #-15
  ADD R1, R1, #-5
  BRn NEXT2
  LEA R0, LETTERGRADEB
  PUTS
  BR SKIP
  NEXT2
  ADD R1, R2, #-15
  ADD R1, R1, #-15
  ADD R1, R1, #-15
  ADD R1, R1, #-15
  ADD R1, R1, #-10
  BRn NEXT3
  LEA R0, LETTERGRADEC
  PUTS
  BR SKIP
  NEXT3
  ADD R1, R2, #-15
  ADD R1, R1, #-15
  ADD R1, R1, #-15
  ADD R1, R1, #-15
  BRn NEXT4
  LEA R0, LETTERGRADED
  PUTS
  BR SKIP
  NEXT4
  LEA R0, LETTERGRADEF
  PUTS
  SKIP LD R0, LETTERGRADEBRANCHRESTORER0
  LD R1, LETTERGRADEBRANCHRESTORER1
  LD R2, LETTERGRADEBRANCHRESTORER2
  LD R7, LETTERGRADEBRANCHRESTORER7
  RET

LETTERGRADEBRANCHRESTORER0 .FILL x0
LETTERGRADEBRANCHRESTORER1 .FILL x0
LETTERGRADEBRANCHRESTORER2 .FILL x0
LETTERGRADEBRANCHRESTORER7 .FILL x0

DECIMALCHAR .FILL X2E



LETTERGRADEA .STRINGZ "\nThe LETTER GRADE IS: A \n"
LETTERGRADEB .STRINGZ "\nThe LETTER GRADE IS: B \n"
LETTERGRADEC .STRINGZ "\nThe LETTER GRADE IS: C \n"
LETTERGRADED .STRINGZ "\nThe LETTER GRADE IS: D \n"
LETTERGRADEF .STRINGZ "\nThe LETTER GRADE IS: F \n"


DECIMAL ;********************************************
ADD R0,R0,#-15
ADD R0,R0,#-15
ADD R0,R0,#-15
ADD R0,R0,#-3
RET

ASCII ;******************************************************
ADD R0,R0,#15
ADD R0,R0,#15
ADD R0,R0,#15
ADD R0,R0,#3
RET



;stack*******************************************************************
;initialize stack SUBROUTINE
STACK

      AND R0, R0, #0
      ST R0, STACKSIZE
      LD R0, STACKBOTTOM
      ST R0, STACKTOP
      LD R0, STACKCAPACITY
      RET

STACKBOTTOM .FILL x4100   ;base of the stack
STACKSIZE .BLKW #1      ;initialize the variable to hold the size of the stack
STACKTOP .BLKW #1       ;will keep pointing to the top of the stack;originally pointing to x4000
STACKCAPACITY .FILL #5  ;only five elements are allowed in the stack;must 

;initialize the push subroutine 
PUSH
      ST R1, SAVER1
      ST R2, SAVER2
      LD R1, STACKSIZE
      LD R2, STACKCAPACITY
      NOT R2, R2        ;compare the size with the capacity by subtracting them
      ADD R2, R2, #1
      ADD R2, R1, R2
      BRz ISFULL        ;if the stack is full move on to the ISFULL 
      ;if stack is not full then continue to add an element onto the stack
      LD R2, STACKTOP   ;LOAD STACKTOP POINTER TO R2
      ADD R2, R2, #-1   ;MUST ADD -1 AS PUSHING 
      STR R0, R2, #0    ;PUSH element;will change
      ST R2, STACKTOP   ;UPDATE TOP OF THE STACK
      ADD R1, R1, #1    
      ST R1, STACKSIZE  ;ADD ONE TO STACKSIZE TO INCREMENT THE size
      ADD R5, R5, #1

;IF STACK IS FULL, NO MORE ELEMENTS CAN BE ADDED
ISFULL 
      LD R1, SAVER1
      LD R2, SAVER2
      RET
SAVER1  .FILL x0  ;SAVE REGISTER 1
SAVER2  .FILL x0  ;SAVE REGISTER 2
STACKFULLMESSAGE .STRINGZ "STACK IS FULL. CAN NO LONGER ADD ELEMENTS\n" ;error message

;initialize pop subroutine
POP
      ST R1, POPSAVER1
      ST R2, POPSAVER2
      AND R5, R5, #0
      LD R1, STACKSIZE  ;LOAD STACKSIZE TO R1
      BRz ISEMPTY       ;IF STACKSIZE = 0, CAN NO LONGER POP, CONT TO ISEMPTY SUBROUTINE
      LD R2, STACKTOP
      LDR R0, R2, #0    ;POP ELEMENT ;USING LDR SINCE WE USED STR IN PUSH SUBROUTINE
      ADD R2, R2, #1    ;MUST ADD 1 AS POPPING
      ST R2, STACKTOP
      ADD R1, R1, #-1   ;DELETE ONE FROM THE STACKSIZE
      ST R1, STACKSIZE  ;UPDATE size
      ADD R5, R5, #1

;SUBROUTINE FOR IF STACK IS EMPTY;NO MORE ELEMENTS CAN BE POPPED
ISEMPTY
      LD R1, POPSAVER1
      LD R2, POPSAVER2
      RET
POPSAVER1 .FILL x0      ;SAVE REGISTER 1
POPSAVER2 .FILL x0      ;SAVE REGISTER 2
STACKEMPTYMESSAGE .STRINGZ "STACK IS EMPTY. CAN NO LONGER REMOVE ELEMENTS\n"  ;error message

;Calculate minimum***********************************************************

CALMIN  ST R1, CALMINRESTORER1; SAVE REGISTERS
ST R2, CALMINRESTORER2
ST R3, CALMINRESTORER3
ST R4, CALMINRESTORER4
ST R5, CALMINRESTORER5

LDI R1, STACKTOP ;Set Head value as minimum
LD R2, STACKSIZE   ;Set R2 as STACKSIZE
ADD R2, R2, #-1   ;R2 = STACKSIZE - 1 (iterate through stack except first element)
LD R3, STACKTOP      ;Set R3 as index
ADD R3, R3, #1    ; Increment index by 1

MINLOOP LDR R4, R3, x0 ;Load stack value at index
NOT R4, R4
ADD R4, R4, #1  ;2'S COMPLEMENT : R4 = -STACKELEMENT
ADD R5, R1, R4  ; R5 = MIN - STACKELEMENT
BRnz MINSKIP
NOT R4, R4
ADD R4, R4, #1 ;2'S COMPLEMENT : R4 = STACKELEMENT
ADD R1, R4, x0 ; MIN = STACKELEMENT
MINSKIP ADD R3, R3, #1 ; INCREMENT INDEX
ADD R2, R2, #-1 ; DECREMENT COUNTER
BRp MINLOOP
ST R1, MIN; STORE R1 TO MIN ADDRESS

LD R1, CALMINRESTORER1; RESTORE REGISTERS
LD R2, CALMINRESTORER2
LD R3, CALMINRESTORER3
LD R4, CALMINRESTORER4
LD R5, CALMINRESTORER5
RET

MIN .FILL x0
CALMINRESTORER1 .FILL x0
CALMINRESTORER2 .FILL x0
CALMINRESTORER3 .FILL x0
CALMINRESTORER4 .FILL x0
CALMINRESTORER5 .FILL x0

;MAXINUM CALCULATOR**********************************************

CALMAX ST R1, CALMAXRESTORER1; SAVE REGISTERS
ST R2, CALMAXRESTORER2
ST R3, CALMAXRESTORER3
ST R4, CALMAXRESTORER4
ST R5, CALMAXRESTORER5
LDI R1, STACKTOP ;Set Head value as MAX
LD R2, STACKSIZE   ;Set R2 as STACKSIZE
ADD R2, R2, #-1   ;R2 = STACKSIZE - 1 (iterate through stack except first element)
LD R3, STACKTOP      ;Set R3 as index
ADD R3, R3, #1    ; Increment index by 1

MAXLOOP LDR R4, R3, x0 ;Load stack value at index
NOT R4, R4
ADD R4, R4, #1  ;2'S COMPLEMENT : R4 = -STACKELEMENT
ADD R5, R1, R4  ; R5 = MAX - STACKELEMENT
BRzp MAXSKIP
NOT R4, R4
ADD R4, R4, #1 		;2'S COMPLEMENT : R4 = STACKELEMENT
ADD R1, R4, x0 		; MAX = STACKELEMENT
MAXSKIP ADD R3, R3, #1		; INCREMENT INDEX
ADD R2, R2, #-1 		; DECREMENT COUNTER
BRp MAXLOOP
ST R1, MAX			; STORE R1 TO MAX ADDRESS

LD R1, CALMAXRESTORER1; RESTORE REGISTERS
LD R2, CALMAXRESTORER2
LD R3, CALMAXRESTORER3
LD R4, CALMAXRESTORER4
LD R5, CALMAXRESTORER5
RET

MAX .FILL x0
CALMAXRESTORER1 .FILL x0
CALMAXRESTORER2 .FILL x0
CALMAXRESTORER3 .FILL x0
CALMAXRESTORER4 .FILL x0
CALMAXRESTORER5 .FILL x0

;AVERAGE CALCULATOR************************************************************
CALAVG ST R1, CALAVGRESTORER1; SAVE REGISTERS
ST R2, CALAVGRESTORER2
ST R3, CALAVGRESTORER3
ST R4, CALAVGRESTORER4
ST R5, CALAVGRESTORER5
ST R7, CALAVGRESTORER7 ; SAVE RETURN ADDRESS, SINCE WE ARE USING NESTED SUBROUTINE
AND R1, R1, x0 ; CLEAR R1, USE AS ACCUMULATOR
LD R2, STACKTOP          ; USE R2 FOR INDEX
LD R3, STACKSIZE ; LOAD STACKSIZE FOR COUNTER
ACCLOOP
LDR R4, R2, x0 ; LOAD STACKELEMENT AT INDEX
ADD R1, R1, R4 ; ACC = ACC + STACKELEMENT
ADD R2, R2, #1 ; INCREMENT INDEX
ADD R3, R3, #-1 ; DECREMENT COUNTER
BRp ACCLOOP
LD R2, STACKSIZE ; REUSE R2 TO LOAD STACKSIZE
ST R1, N; STORE R1 (SUM) INTO NUMERATOR
ST R2, D; STORE R2 (STACKSIZE) INTO DENOMINATOR
JSR DIV
LD R1, QUOTIENT; REUSE R1 TO LOAD QUOTIENT
ST R1, AVGINT; STORE INTEGER PART OF AVERAGE TO AVGINT
LD R1, REMAINDER; LOAD REMAINDER INTO R1
LD R3, HUNDRED ; LOAD 100 INTO R3
ST R1, Y ; STORE AVG REMAINDER INTO MULTIPLICAND
ST R3, X ; STORE HUNDRED TO MULTIPLIER
JSR MULT
LD R1, XTIMESY ; REUSE R1 TO STORE AVG REMAINDER TIMES 100
ST R1, N ; STORE R1 (AVG REMAINDER * 100) INTO NUMERATOR
ST R2, D ; STORE R2 (STACKSIZE) INTO DENOMINATOR
JSR DIV
LD R1, QUOTIENT ; REUSE R1 TO LOAD QUOTIENT (DECIMAL PART OF AVG)
LD R3, REMAINDER ; REUSE R3 TO LOAD SECOND REMAINDER
AND R4, R4, x0 ; CLEAR R4
ADD R4, R4, #2 ; R4 = 2
ST R2, N ; STORE STACKSIZE INTO NUMERATOR
ST R4, D ; STORE 2 INTO DENOMINATOR
JSR DIV
LD R4, REMAINDER ; REUSE R4 TO HOLD REMAINDER OF STACKSIZE / 2
LD R5, QUOTIENT ; REUSE R5 TO HOLD STACKSIZE / 2
ADD R4, R4, #0 ; R4 = R4 + 0
BRz STACKEVEN ; DETERMINE STACK PARITY TO DETERMINE ROUNDING CUT
ADD R2, R2, #-1 ; R2 = STACKSIZE - 1
AND R4, R4, #0 ; CLEAR R4
ADD R4, R4, #2 ; R4 = 2
ST R2, N ; STORE STACKSIZE = 1 INTO NUMERATOR
ST R4, D ; STORE 2 INTO DENOMINATOR
JSR DIV
LD R4, QUOTIENT; R4 = (STACKSIZE - 1) / 2 = ROUNDING CUT
BR AVGSKIP
STACKEVEN ADD R4, R5, #-1 ; R4 = (STACKSIZE / 2) - 1 = ROUNDING CUT
AVGSKIP NOT R4, R4
ADD R4, R4, #1 ; R4 = MINUS ROUNDING CUT
ADD R2, R3, R4 ; R2 = SECOND REMAINDER - ROUNDING CUT
BRnz ROUNDSKIP
ADD R1, R1, #1 ; R1 = AVGDEC + 1 (ROUND UP DECIMAL PART OF AVERAGE)
ROUNDSKIP ST R1, AVGDEC ; STORE AVGDEC
LD R1, CALAVGRESTORER1 ; RESTORE REGISTERS
LD R2, CALAVGRESTORER2
LD R3, CALAVGRESTORER3
LD R4, CALAVGRESTORER4
LD R5, CALAVGRESTORER5
LD R7, CALAVGRESTORER7 ; RESTORE RETURN ADDRESS
RET

AVGINT .FILL x0
AVGDEC .FILL x0
HUNDRED .FILL #100
CALAVGRESTORER1 .FILL x0
CALAVGRESTORER2 .FILL x0
CALAVGRESTORER3 .FILL x0
CALAVGRESTORER4 .FILL x0
CALAVGRESTORER5 .FILL x0
CALAVGRESTORER7 .FILL x0




;NOTE ON MULT AND DIV: THERE SHOULD BE ERROR CHECKING FOR NEGATIVES AND FOR DIVISION BY ZERO
;THIS WILL BE DONE IN INPUT FUNCTIONS, HOWEVER, SO MULT AND DIV SUBROUTINES SHOULD BE FINE

;MULTIPLICATION*******************************************************
;BITSHIFT MULTIPLICATION
;ASSUME R1 = X IS MULTIPLIER AND R2 = Y IS MULTIPLICAND. ALTERNATIVE IS MEMORY LOCATIONS
MULT ST R1, MULTRESTORER1 ; SAVE REGISTER
ST R2, MULTRESTORER2
ST R3, MULTRESTORER3
ST R4, MULTRESTORER4
ST R5, MULTRESTORER5
LD R1, X; LOAD X
LD R2, Y; LOAD Y
AND R3, R3, x0 ; CLEAR R3
ADD R3, R3, x1 ; SET R3 AS BIT THAT WE ARE MULTIPLYING AT
AND R4, R4, x0 ; CLEAR R4, SET R4 AS ACCUMULATOR
AND R5, R5, x0 ; CLEAR R5
ADD R5, R5, #15 ; SET R5 AS COUNTER

MULTLOOP AND R6, R2, R3; CHECK IF BIT IS EQUAL TO ZERO
BRz MULTISZERO
ADD R4, R4, R1; ADD MULTIPLIED x0
MULTISZERO ADD R3, R3, R3 ; R3 = 2 * R3, MULTIPLY BIT BY BINARY 10
ADD R1, R1, R1; R1 = 2 * R1, MULTIPLY X BY BINARY 10
ADD R5, R5, #-1 ; DECREMENT COUNTER
BRp MULTLOOP
ST R4, XTIMESY; RETURN RESULT
LD R1, MULTRESTORER1 ; RESTORE REGISTERS
LD R2, MULTRESTORER2
LD R3, MULTRESTORER3
LD R4, MULTRESTORER4
LD R5, MULTRESTORER5
RET

X .FILL x0
Y .FILL x0
XTIMESY .FILL x0
MULTRESTORER1 .FILL x0
MULTRESTORER2 .FILL x0
MULTRESTORER3 .FILL x0
MULTRESTORER4 .FILL x0
MULTRESTORER5 .FILL x0

;DIVISION********************************************************************
;NOT BITSHIFT
;ASSUME R1 = N FOR NUMERATOR AND R2 = D FOR DENOMINATOR
; R1 WILL OUTPUT REMAINDER, R3 WILL OUTPUT QUOTIENT
;NOTE: BRANCHING COULD BE OPTIMIZED

DIV ST R1, DIVRESTORER1 ; SAVE REGISTERS
ST R2, DIVRESTORER2
ST R3, DIVRESTORER3
LD R1, N ; LOAD N
LD R2, D ; LOAD D
AND R3, R3, #0 ; CLEAR R3, SET AS ACCUMULATOR/QUOTIENT
NOT R2, R2
ADD R2, R2, #1; 2S COMPLEMENT : R2 = -D
DIVLOOP ADD R1, R1, R2 ; R = R - D
BRnz BREAKDIV ; IF REMAINDER IS ZERO OR NEGATIVE, BREAK LOOP
ADD R3, R3, #1; INCREMENT QUOTIENT
BR DIVLOOP
BREAKDIV ADD R1, R1, #0 ; R1 = R + 0
BRn ADDREMAINDER
ADD R3, R3, #1 ; ADD 1 TO Q, SINCE WE SKIP THIS INSTRUCTION WHEN WE BREAK LOOP
BR DIVSKIP
ADDREMAINDER NOT R2, R2
ADD R2, R2, #1 ; 2S COMPLEMENT : R2 = DENOMINATOR
ADD R1, R1, R2 ; R1 = R + D (MAKE SURE REMAINDER IS POSITIVE)
DIVSKIP ST R3, QUOTIENT ; STORE R3 TO QUOTIENT
ST R1, REMAINDER; STORE R1 TO REMAINDER
LD R1, DIVRESTORER1
LD R2, DIVRESTORER2
LD R3, DIVRESTORER3
RET

N .FILL x0
D .FILL x0
QUOTIENT .FILL x0
REMAINDER .FILL x0
DIVRESTORER1 .FILL x0
DIVRESTORER2 .FILL x0
DIVRESTORER3 .FILL x0

.END